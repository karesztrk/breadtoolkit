---
import Layout from "@layouts/Layout.astro";

const title = "Browser API Detector";
---

<Layout title={title}>
  <header>
    <h1>{title}</h1>
  </header>

  <section id="overallStatus" role="status" aria-live="polite">
    <h2>Status</h2>
    <p id="statusText">Detecting...</p>
  </section>

  <section>
    <h2>Browser</h2>
    <p id="browserInfo">...</p>
  </section>

  <section>
    <h2>Speech Synthesis API</h2>
    <aside id="speechStatus" role="status" aria-live="polite">
      <p id="speechStatusText">Detecting...</p>
    </aside>

    <dl>
      <dt>API</dt>
      <dd>
        <span id="apiAvailable"></span>
        API Available
      </dd>
      <dt>Voices</dt>
      <dd>
        <span id="voicesLoaded"></span>
        Voices Loaded
      </dd>
      <dt>Voice Count</dt>
      <dd id="voiceCount">0</dd>
    </dl>

    <section>
      <h3>Speech Synthesis Features</h3>
      <dl id="speechFeaturesList"></dl>
    </section>

    <section id="speechErrorsSection">
      <h3>Speech Synthesis Issues</h3>
      <ul id="speechErrorsList"></ul>
    </section>
  </section>


  <section>
    <h2>CSS Custom Highlight API</h2>
    <aside id="highlightStatus" role="status" aria-live="polite">
      <p id="highlightStatusText">Detecting...</p>
    </aside>

    <section id="highlightFeaturesSection">
      <h3>CSS Highlight Features</h3>
      <dl id="highlightFeaturesList"></dl>
    </section>

    <section id="highlightErrorsSection">
      <h3>CSS Highlight Issues</h3>
      <ul id="highlightErrorsList"></ul>
    </section>
  </section>


  <section>
    <fieldset role="group" data-spaced>
      <button id="testBtn" type="button">Test Speech Synthesis</button>
      <button id="refreshBtn" type="button">Re-detect</button>
    </fieldset>
  </section>
</Layout>

<script>
let support = {
  speechSynthesis: {
    available: false,
    voicesLoaded: false,
    voiceCount: 0,
    features: {},
    errors: []
  },
  cssHighlight: {
    available: false,
    features: {},
    errors: []
  },
  browser: ''
};
let testing = false;

function createIcon(status) {
  if (status === true) {
    return '✓';
  } else if (status === false) {
    return '✗';
  } else {
    return '!';
  }
}

function createIconElement(status) {
  const span = document.createElement('span');
  span.textContent = createIcon(status);
  return span;
}

function getBrowserInfo() {
  const ua = navigator.userAgent;
  if (ua.includes('Edg')) return 'Edge';
  if (ua.includes('Chrome')) return 'Chrome';
  if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
  if (ua.includes('Firefox')) return 'Firefox';
  if (ua.includes('Opera') || ua.includes('OPR')) return 'Opera';
  return 'Unknown Browser';
}

function detectSupport() {
  support = {
    speechSynthesis: {
      available: false,
      voicesLoaded: false,
      voiceCount: 0,
      features: {},
      errors: []
    },
    cssHighlight: {
      available: false,
      features: {},
      errors: []
    },
    browser: getBrowserInfo()
  };

  detectSpeechSynthesis();
  detectCSSHighlight();
  updateUI();
}

function detectSpeechSynthesis() {
  try {
    if (!window.speechSynthesis || !('speechSynthesis' in window)) {
      support.speechSynthesis.errors.push('Speech Synthesis API not available in this browser');
      return;
    }

    support.speechSynthesis.available = true;

    support.speechSynthesis.features = {
      speak: typeof window.speechSynthesis.speak === 'function',
      cancel: typeof window.speechSynthesis.cancel === 'function',
      pause: typeof window.speechSynthesis.pause === 'function',
      resume: typeof window.speechSynthesis.resume === 'function',
      getVoices: typeof window.speechSynthesis.getVoices === 'function',
      speechSynthesisUtterance: typeof window.SpeechSynthesisUtterance === 'function'
    };

    const checkVoices = () => {
      try {
        const voices = window.speechSynthesis.getVoices();
        support.speechSynthesis.voiceCount = voices.length;
        support.speechSynthesis.voicesLoaded = voices.length > 0;

        if (voices.length === 0) {
          support.speechSynthesis.errors = support.speechSynthesis.errors.filter(e => !e.includes('voices'));
          support.speechSynthesis.errors.push('No voices available (they may still be loading)');
        } else {
          support.speechSynthesis.errors = support.speechSynthesis.errors.filter(e => !e.includes('voices'));
        }

        updateUI();
      } catch (err) {
        support.speechSynthesis.errors.push('Error loading voices: ' + err.message);
        updateUI();
      }
    };

    checkVoices();

    if (window.speechSynthesis.addEventListener) {
      window.speechSynthesis.addEventListener('voiceschanged', checkVoices);
    } else if (window.speechSynthesis.onvoiceschanged !== undefined) {
      window.speechSynthesis.onvoiceschanged = checkVoices;
    }

    setTimeout(checkVoices, 100);

  } catch (err) {
    support.speechSynthesis.errors.push('Detection error: ' + err.message);
  }
}

function detectCSSHighlight() {
  try {
    const selectorSupport = CSS.supports("selector(::highlight(test))");
    if (!window.CSS || !CSS.highlights || !selectorSupport) {
      support.cssHighlight.errors.push('CSS Custom Highlight API not available in this browser');
      return;
    }

    support.cssHighlight.available = true;

    support.cssHighlight.features = {
      highlights: typeof CSS.highlights === 'object',
      set: typeof CSS.highlights.set === 'function',
      delete: typeof CSS.highlights.delete === 'function',
      clear: typeof CSS.highlights.clear === 'function',
      has: typeof CSS.highlights.has === 'function',
      highlight: typeof window.Highlight === 'function',
      range: typeof window.Range === 'function'
    };

  } catch (err) {
    support.cssHighlight.errors.push('Detection error: ' + err.message);
  }
}

function updateUI() {
  const speechFullSupport = support.speechSynthesis.available &&
    support.speechSynthesis.voicesLoaded &&
    Object.values(support.speechSynthesis.features).every(f => f === true);

  const highlightFullSupport = support.cssHighlight.available &&
    Object.values(support.cssHighlight.features).every(f => f === true);

  // Overall Status
  const bothFullySupported = speechFullSupport && highlightFullSupport;
  const anySupported = support.speechSynthesis.available || support.cssHighlight.available;


  document.getElementById('statusText').textContent =
    (bothFullySupported ? '✓ All APIs Fully Supported' :
      anySupported ? '! Some APIs Supported' :
        '✗ No APIs Supported');

  // Browser Info
  document.getElementById('browserInfo').textContent = support.browser;

  // Speech Synthesis Status
  const speechStatus = document.getElementById('speechStatus');
  speechStatus.className = speechFullSupport ? 'success' : support.speechSynthesis.available ? 'warning' : 'error';

  document.getElementById('speechStatusText').textContent =
    (speechFullSupport ? '✓ Fully Supported' :
      support.speechSynthesis.available ? '! Partially Supported' :
        '✗ Not Supported');

  // Speech API Status
  const apiAvailable = document.getElementById('apiAvailable');
  apiAvailable.textContent = createIcon(support.speechSynthesis.available);

  const voicesLoaded = document.getElementById('voicesLoaded');
  voicesLoaded.textContent = createIcon(support.speechSynthesis.voicesLoaded);

  document.getElementById('voiceCount').textContent = `${support.speechSynthesis.voiceCount}`;

  // Speech Features
  const speechFeaturesList = document.getElementById('speechFeaturesList');

  if (support.speechSynthesis.available) {
    speechFeaturesList.innerHTML = '';

    Object.entries(support.speechSynthesis.features).forEach(function(entry) {
      const [feature, available] = entry;

      const title = document.createElement('dt');
      title.textContent = feature.replace(/([A-Z])/g, ' $1').trim();

      const term = document.createElement('dd');

      term.appendChild(createIconElement(available));
      term.append(` ${feature.replace(/([A-Z])/g, '$1')}`);

      speechFeaturesList.appendChild(title);
      speechFeaturesList.appendChild(term);
    });
  }

  // Speech Errors
  const speechErrorsList = document.getElementById('speechErrorsList');

  if (support.speechSynthesis.errors.length > 0) {
    speechErrorsList.innerHTML = '';

    support.speechSynthesis.errors.forEach(function(error) {
      const li = document.createElement('li');
      li.textContent = '! ' + error;
      speechErrorsList.appendChild(li);
    });
  }

  // CSS Highlight Status
  const highlightStatus = document.getElementById('highlightStatus');
  highlightStatus.className = highlightFullSupport ? 'success' : support.cssHighlight.available ? 'warning' : 'error';

  document.getElementById('highlightStatusText').textContent =
    (highlightFullSupport ? '✓ Fully Supported' :
      support.cssHighlight.available ? '! Partially Supported' :
        '✗ Not Supported');

  // CSS Highlight Features
  const highlightFeaturesList = document.getElementById('highlightFeaturesList');

  if (support.cssHighlight.available) {
    highlightFeaturesList.innerHTML = '';

    Object.entries(support.cssHighlight.features).forEach(function(entry) {
      const [feature, available] = entry;

      const title = document.createElement('dt');
      title.textContent = feature.replace(/([A-Z])/g, ' $1').trim();


      const term = document.createElement('dd');
      term.appendChild(createIconElement(available));
      term.append(` ${feature.replace(/([A-Z])/g, '$1')}`);

      highlightFeaturesList.appendChild(title);
      highlightFeaturesList.appendChild(term);
    });
  }

  // CSS Highlight Errors
  const highlightErrorsList = document.getElementById('highlightErrorsList');

  if (support.cssHighlight.errors.length > 0) {
    highlightErrorsList.innerHTML = '';

    support.cssHighlight.errors.forEach(function(error) {
      const li = document.createElement('li');
      li.textContent = '! ' + error;
      highlightErrorsList.appendChild(li);
    });
  }
}

function testSpeech() {
  if (!support.speechSynthesis.available || !support.speechSynthesis.voicesLoaded || testing) return;

  testing = true;
  const testBtn = document.getElementById('testBtn');
  testBtn.disabled = true;
  testBtn.textContent = 'Speaking...';

  try {
    window.speechSynthesis.cancel();

    const utterance = new window.SpeechSynthesisUtterance('Speech synthesis is working correctly.');

    utterance.onend = function() {
      testing = false;
      testBtn.disabled = false;
      testBtn.textContent = 'Test Speech Synthesis';
    };

    utterance.onerror = function(e) {
      testing = false;
      testBtn.disabled = false;
      testBtn.textContent = 'Test Speech Synthesis';
      alert('Speech Error: ' + e.error);
    };

    window.speechSynthesis.speak(utterance);
  } catch (err) {
    testing = false;
    testBtn.disabled = false;
    testBtn.textContent = 'Test Speech Synthesis';
    alert('Error: ' + err.message);
  }
}

document.getElementById('testBtn').addEventListener('click', testSpeech);
document.getElementById('refreshBtn').addEventListener('click', detectSupport);

window.addEventListener('beforeunload', function() {
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
});

detectSupport();
</script>
